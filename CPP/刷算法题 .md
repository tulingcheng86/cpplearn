#  刷算法题  c++

目标每天刷3~5道题

总共210道题，已刷

# 16/210

## 数组

 ### 1、二分查找

写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。

-----------------------------------

**左闭右闭即[left, right]**

区间的定义这就决定了二分法的代码应该如何写，**因为定义target在[left, right]区间，所以有如下两点：**

- while (left <= right) 要使用 **<=** ，**因为left == right是有意义的**，所以使用 <=
- if (nums[middle] > target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1
- 

-----------------------------------

**左闭右开即[left, right)。**

有如下两点：

- while (left < right)，这里使用 < ,因为left == right在区间[left, right)是没有意义的
- if (nums[middle] > target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]



**总结：开区间不用对mid做加减，闭区间需要**



力扣题目

[704. 二分查找](https://leetcode.cn/problems/binary-search/)

[35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/)

[34. 在排序数组中查找元素的第一个和最后一个位置（）两个二分查找找左边界右边界](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)
**写两个二分分别找左边界和右边界**

```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) 
    {
    int first = findFirstPosition(nums, target);
    int last = findLastPosition(nums, target);
    
    if (first <= last) {
        return {first, last};
    } else {
        return {-1, -1};
    }
    }

private:
   int findFirstPosition(std::vector<int>& nums, int target) 
{
    int left = 0;
    int right = nums.size() - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return left;
}

int findLastPosition(std::vector<int>& nums, int target) 
{
    int left = 0;
    int right = nums.size() - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] <= target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return right;
}

};
```

[69. x 的平方根 ](https://leetcode.cn/problems/sqrtx/)

按左闭右开算

### 2、移除元素

**重点：双指针**

**原地移除元素**

[27. 移除元素](https://leetcode.cn/problems/remove-element/)

[26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

[283. 移动零](https://leetcode.cn/problems/move-zeroes/)

```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) 
    {
        int slow=0;
        for(int fast =0;fast<nums.size();fast++)
        {
            if(nums[fast]!=0)
            {
                nums[slow++]=nums[fast];
            }
        }
        for(int fast=slow;fast<nums.size();fast++)
        {
            nums[fast]=0;
        }    

    }
};
```

### 3、有序数组的平方

[977. 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)



### 4、长度最小的子数组（滑动窗口）

[209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

所谓滑动窗口，**就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果**。

```c++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) 
    {
        int i=0;
        int result = INT32_MAX;//INT32_MAX 是一个宏定义，表示 int 类型的最大值。
        int sum=0;// 滑动窗口数值之和
        int len=0;// 滑动窗口长度
        for(int j=0;j<nums.size();j++)
        {   
            sum+=nums[j];
            while(sum>=target)
            {
                len=j-i+1;// 取子序列的长度
                result=min(result,len);
                sum-=nums[i++]; // 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）
            }
        
        }
        // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列
        return result == INT32_MAX ? 0 : result;
    }
};
```



### 5、螺旋矩阵（不会==）



## 链表

### 链表的定义

```c++
//单链表
struct ListNode{
    int val;// 节点上存储的元素
    ListNode *next;// 指向下一个节点的指针
    ListNode(int x):val(x),next(NULL){}// 节点的构造函数
}
```

### 删除节点

![image-20240228103012346](C:\Users\tlc\AppData\Roaming\Typora\typora-user-images\image-20240228103012346.png)

### 添加节点

![image-20240228103027608](C:\Users\tlc\AppData\Roaming\Typora\typora-user-images\image-20240228103027608.png)

### 1、移除链表元素

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) 
    {
        //先创建虚拟节点
        ListNode *cur=new ListNode(0);
        cur->next=head;
        ListNode *fast=cur->next;
        ListNode *slow=cur;
        while(fast!=NULL)
        {
            if(fast->val==val)
            {
                slow->next=fast->next;
                fast=fast->next;
            }
            else
            {
                fast=fast->next;
                slow=slow->next;
            }
        }
        return cur->next;
    }
};
```



### 2、删除链表的倒数第N个结点

[19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

思路：用双指针，快指针先到第N个位置，然后在一起移动,这样慢指针就能到倒数第N个结点位置了

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        if(head==nullptr)return nullptr;

        ListNode *cur=new ListNode(0);
        cur -> next = head;
        ListNode *fast = cur;
        ListNode *slow = cur;

        for (int i = 0; i < n && fast != nullptr; i++) {
            fast = fast->next;
        }
        while (fast->next != nullptr) {
            fast = fast->next;
            slow = slow->next;
        }

        slow->next=slow->next->next;
        return cur->next;
    }
};
```

### 3、翻转链表

[206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

思路：如果再定义一个新的链表，实现链表元素的反转，其实这是对内存空间的浪费。

其实只需要改变链表的next指针的指向，直接将链表反转 ，而不用重新定义一个新的链表，如图所示:

![image-20240228155811639](C:\Users\tlc\AppData\Roaming\Typora\typora-user-images\image-20240228155811639.png)

```c++
class Solution {
public:
    ListNode* reverseList(ListNode* head) 
    {
        ListNode *cur=head;
        ListNode *tmp;
        ListNode *p=NULL;
        while(cur!=nullptr)
        {   
            tmp=cur->next;
            cur->next=p;
            p=cur;
            cur=tmp;
        }
        return p;
    }
};
```



### 4、两两交换链表中的结点

[24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)

![image-20240228161806081](C:\Users\tlc\AppData\Roaming\Typora\typora-user-images\image-20240228161806081.png)

![image-20240228162946473](C:\Users\tlc\AppData\Roaming\Typora\typora-user-images\image-20240228162946473.png)

```c++
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode* dummyHead = new ListNode(0); // 设置一个虚拟头结点
        dummyHead->next = head; // 将虚拟头结点指向head，这样方便后面做删除操作
        ListNode* cur = dummyHead;
        while(cur->next != nullptr && cur->next->next != nullptr) {
            ListNode* tmp = cur->next; // 记录临时节点
            ListNode* tmp1 = cur->next->next->next; // 记录临时节点

            cur->next = cur->next->next;    // 步骤一
            cur->next->next = tmp;          // 步骤二
            cur->next->next->next = tmp1;   // 步骤三

            cur = cur->next->next; // cur移动两位，准备下一轮交换
        }
        return dummyHead->next;
    }
};
```



## 哈希表

###  常见的三种哈希结构

当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。

- 数组

- set （集合）

- map(映射)

  
  ![image-20240228222655359](C:\Users\tlc\AppData\Roaming\Typora\typora-user-images\image-20240228222655359.png)

### 1、有效的字母异位词

[242. 有效的字母异位词](https://leetcode.cn/problems/valid-anagram/)

```c++
class Solution {
public:
    bool isAnagram(string s, string t) 
    {
        unordered_map<char,int>s_count,t_count;
        for(char c:s)
        {
            s_count[c]++;
        }
        for(char c:t)
        {
            t_count[c]++;
        }
        return s_count==t_count;
    }
};
```



### 2.两个数组的交集

哈希表 unordered_map

```c++
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) 
    {
        unordered_map<int,int> s;
        vector<int>result;
        for(int num:nums1)
        {
            s[num]++;
        }
        for(int num:nums2)
        {
            if(s[num]>0)
            {
                result.push_back(num);
                s[num]=0;
            }
        }
        return result;

    }
};
```

[350. 两个数组的交集 II](https://leetcode.cn/problems/intersection-of-two-arrays-ii/)



### 3、两数之和（用哈希表方法的没懂）

[1. 两数之和](https://leetcode.cn/problems/two-sum/)

**map用来存放遍历过的元素**

```
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        std::unordered_map <int,int> map;
        for(int i = 0; i < nums.size(); i++) {
            // 遍历当前元素，并在map中寻找是否有匹配的key
            auto iter = map.find(target - nums[i]); 
            if(iter != map.end()) {
                return {iter->second, i};
            }
            // 如果没找到匹配对，就把访问过的元素和下标加入到map中
            map.insert(pair<int, int>(nums[i], i)); 
        }
        return {};
    }
};
```



### 4、赎金信

[383. 赎金信](https://leetcode.cn/problems/ransom-note/)

### 5、三数之和

[15. 三数之和](https://leetcode.cn/problems/3sum/)



## 字符串

[344. 反转字符串](https://leetcode.cn/problems/reverse-string/)

[541. 反转字符串 II](https://leetcode.cn/problems/reverse-string-ii/)



## 双指针法

[27. 移除元素](https://leetcode.cn/problems/remove-element/)

[344. 反转字符串](https://leetcode.cn/problems/reverse-string/)







## 栈与队列 stack queque

### 理论基础

![image-20240229201609826](C:\Users\13995\AppData\Roaming\Typora\typora-user-images\image-20240229201609826.png)

所以STL中栈往往不被归类为容器，而被归类为container adapter（容器适配器）。



### 1.用栈实现队列

[232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)


![image-20240301214704007](C:\Users\BT7274\AppData\Roaming\Typora\typora-user-images\image-20240301214704007.png)

```c++
class MyQueue {
public:
    stack<int>In;
    stack<int>Out;
    MyQueue() {

    }
    
    void push(int x) {
        In.push(x);
    }
    
    int pop() {
        if(Out.empty())
        {
            while(!In.empty())
            {   
                Out.push(In.top());
                In.pop();
            }
        }
        int result = Out.top();
        Out.pop();
        return result;
    }
    
    int peek() {
        int res = this->pop(); // 直接使用已有的pop函数
        Out.push(res); // 因为pop函数弹出了元素res，所以再添加回去
        return res;
    }
    
    bool empty() {
        return In.empty() && Out.empty();
    }
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj = new MyQueue();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->peek();
 * bool param_4 = obj->empty();
 */
```



### 2.用队列实现栈

[225. 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)

![image-20240301221859314](C:\Users\BT7274\AppData\Roaming\Typora\typora-user-images\image-20240301221859314.png)



**两个队列实现**

```c++
class MyStack {
public:
    queue<int> que1;
    queue<int> que2; // 辅助队列，用来备份
    /** Initialize your data structure here. */
    MyStack() {

    }

    /** Push element x onto stack. */
    void push(int x) {
        que1.push(x);
    }

    /** Removes the element on top of the stack and returns that element. */
    int pop() {
        int size = que1.size();
        size--;
        while (size--) { // 将que1 导入que2，但要留下最后一个元素
            que2.push(que1.front());
            que1.pop();
        }

        int result = que1.front(); // 留下的最后一个元素就是要返回的值
        que1.pop();
        que1 = que2;            // 再将que2赋值给que1
        while (!que2.empty()) { // 清空que2
            que2.pop();
        }
        return result;
    }

    /** Get the top element. */
    int top() {
        return que1.back();
    }

    /** Returns whether the stack is empty. */
    bool empty() {
        return que1.empty();
    }
};
```

#### 优化

其实这道题目就是用一个队列就够了。

**一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时再去弹出元素就是栈的顺序了。**

```c++
class MyStack {
public:
    queue<int> que;
    /** Initialize your data structure here. */
    MyStack() {

    }
    /** Push element x onto stack. */
    void push(int x) {
        que.push(x);
    }
    /** Removes the element on top of the stack and returns that element. */
    int pop() {
        int size = que.size();
        size--;
        while (size--) { // 将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部
            que.push(que.front());
            que.pop();
        }
        int result = que.front(); // 此时弹出的元素顺序就是栈的顺序了
        que.pop();
        return result;
    }

    /** Get the top element. */
    int top() {
        return que.back();
    }

    /** Returns whether the stack is empty. */
    bool empty() {
        return que.empty();
    }
};
```



### 3.有效括号

**stack**

**由于栈结构的特殊性，非常适合做对称匹配类的题目。**

```c++
class Solution {
public:
    bool isValid(string s) 
    {  
        stack<char> stack;
        for(char c:s)
        {
            if(c == '{' || c == '[' || c == '(')
            {
                stack.push(c);
            }
            else if(c=='}'||c==']'||c==')')
            {
                if(stack.empty())
                {
                    return false;
                }
                char top=stack.top();
                stack.pop();
                if (c == '}'&&top!='{'|| c == ')' && top != '('|| c == ']' && top != '[')
                {
                    return false;
                }
            }
        }
    return stack.empty();
    }
};
```



## 二叉树 ***（重要）

**介绍**

[关于二叉树，你该了解这些！| 二叉树理论基础一网打尽，二叉树的种类、二叉树的存储方式、二叉树节点定义、二叉树的遍历顺序_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Hy4y1t7ij/?vd_source=ab1c506999c45afa254a9def770c2d68)

**二叉树的定义**

```c++
struct TreeNode
{
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x):val(x),left(NULL),right(NULL){}
}
```

**说到二叉树，就不得不说递归，很多同学对递归都是又熟悉又陌生，递归的代码一般很简短，但每次都是一看就会，一写就废**。



### 1. 二叉树的递归遍历

这里帮助大家确定下来递归算法的三个要素。**每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！**

1. **确定递归函数的参数和返回值：** 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
2. **确定终止条件：** 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
3. **确定单层递归的逻辑：** 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。



**前序遍历**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void qianxu(TreeNode *root,vector<int>& s)//递归三要素 1.确定函数的传入值和返回值
    {   
        if(root==nullptr)return;//2.确定终止条件
        //3.确定递归逻辑
        s.push_back(root->val);
        qianxu(root->left,s);
        qianxu(root->right,s);

    }
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> s;
        qianxu(root,s);
        return s;
    }
};
```



**中序遍历**

```c++
class Solution {
public:
    void inorderTraversal(TreeNode* root,vector<int>& num)
    {
        if(root==nullptr)return;
        inorderTraversal(root->left,num);
        num.push_back(root->val);
        inorderTraversal(root->right,num);

    }
    vector<int> inorderTraversal(TreeNode* root) 
    {   
        vector<int> num;
        inorderTraversal(root,num);
        return num;

    }
};

```

**后序遍历**

```c++
class Solution {
public:
  void postorderTraversal(TreeNode* root,vector<int>& num)
    {
        if(root==nullptr)return;
        postorderTraversal(root->left,num);
        postorderTraversal(root->right,num);
        num.push_back(root->val);

    }
    vector<int> postorderTraversal(TreeNode* root) 
    {
        vector<int>num;
        postorderTraversal(root,num);
        return num;
    }
};

```





### 二叉树最大深度

https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/

```c++
class Solution {
public:
    int travelmax(TreeNode* root)
    {   
        if(root==NULL)return 0;
        int leftnum=travelmax(root->left);
        int rightnum=travelmax(root->right);
        int maxnum=1+max(leftnum,rightnum);
        return maxnum;

    }
    int maxDepth(TreeNode* root) 
    {   
       return  travelmax(root);
    }
};
```

**而根节点的高度就是二叉树的最大深度**，所以本题中我们通过后序求的根节点高度来求的二叉树最大深度。

**确定单层递归的逻辑：先求它的左子树的深度，再求右子树的深度，最后取左右深度最大的数值 再+1 （加1是因为算上当前中间节点）就是目前节点为根节点的树的深度。**



#### **N叉树最大深度**

**知道什么是N叉树，知道怎么定义**

https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    int maxDepth(Node* root) 
    {
        if(root==NULL)return 0;
        int Depth=0;
        for(int i=0;i<root->children.size();i++)
        {
            Depth=max(Depth,maxDepth(root->children[i]));

        }
        return Depth+1;
    }
};
```



### 完全二叉树的节点个数（没懂）

**什么是完全二叉树**

在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^(h-1)  个节点。

[要理解普通二叉树和完全二叉树的区别！ | LeetCode：222.完全二叉树节点的数量](https://leetcode.cn/link/?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1eW4y1B7pD)

[222. 完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/)



**以下是普通二叉树的节点个数代码（遍历法）（没用到完全二叉树的性质，但是也能用来计算完全二叉树的）**

```c++
class Solution {
public:
    int countNodes(TreeNode* root) 
    {
        if(root==NULL)return 0;
        int leftnum=countNodes(root->left);
        int rightnum=countNodes(root->right);
        return 1+rightnum+leftnum;
    }
};
```





### 对称二叉树

[101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)



1. 确定终止条件

要比较两个节点数值相不相同，首先要把两个节点为空的情况弄清楚！否则后面比较数值的时候就会操作空指针了。

节点为空的情况有：（**注意我们比较的其实不是左孩子和右孩子，所以如下我称之为左节点右节点**）

- 左节点为空，右节点不为空，不对称，return false
- 左不为空，右为空，不对称 return false
- 左右都为空，对称，返回true

此时已经排除掉了节点为空的情况，那么剩下的就是左右节点不为空：

- 左右都不为空，比较节点数值，不相同就return false

  
  

**盲目的照着抄，结果就是：发现这是一道“简单题”，稀里糊涂的就过了，但是真正的每一步判断逻辑未必想到清楚。**

```c++
class Solution {
public:
    bool compare(TreeNode*left,TreeNode*right)
    {
        if (left == NULL && right != NULL) return false;
        else if (left != NULL && right == NULL) return false;
        else if (left == NULL && right == NULL) return true;
        else if(left->val!=right->val) return false;
        else 
        {
            bool outside = compare(left->left, right->right);   // 左子树：左、 右子树：右
            bool inside = compare(left->right, right->left);    // 左子树：右、 右子树：左
            bool isduicheng=(outside&&inside);
            return isduicheng;
        }
    }

    bool isSymmetric(TreeNode* root) 
    {
        if(root==NULL)return 0;
        return compare(root->left,root->right);
    }
};
```

