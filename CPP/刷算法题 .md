##  刷算法题  c++  

目标每天刷1~3道题

总共210道题，已刷

## 38/210道  2024/02/27开始 

## 求职准备

以字节为例，面试基本就是算法题+八股文：

算法：leetcode top100 + 剑指offer刷熟绝壁够了，剩下就是看运气了，运气不好碰到憨憨面试官刷个500题可能也不够
八股文：在lc上找10来篇自己岗位的面经，把上面的问题搞熟，推荐：https://github.com/wolverinn/Waking-Up
这就是拿字节offer的步骤，亲测有效。要知道面试的运气成分也非常大，最关键的一点是：永远不要等自己一切都准备好了再投递，因为永远没有完全准备充分的时候，多投递多尝试才是关键！！



面试经常问的需要记下来的，比如三次握手四次挥手，mysql隔离级别，redis的底层数据结构这样的，也不要嗯背，比如在背的时候可以联想具体的例子，在面试的时候可以跟面试官吹吹牛逼举个例子



**好的项目推荐**

1. 做一个业务类型的crud项目，类似于秒杀之类的，接触一下后端常用的存储和基础组件。

2. 做一个底层一点的项目，例如web server。如果时间够可以做一些国外经典课程的lab，比如mit6.824，它的lab组合起来就是一个分布式的kv，你需要自己去实现raft等，面试的时候就比较好吹了。

项目可能更多是问业务场景，解决了什么问题，怎么做存储的，有什么亮点之类的

## 数组

 ### 1、二分查找

写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。

-----------------------------------

**左闭右闭即[left, right]**

区间的定义这就决定了二分法的代码应该如何写，**因为定义target在[left, right]区间，所以有如下两点：**

- while (left <= right) 要使用 **<=** ，**因为left == right是有意义的**，所以使用 <=
- if (nums[middle] > target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1
- 

-----------------------------------

**左闭右开即[left, right)。**

有如下两点：

- while (left < right)，这里使用 < ,因为left == right在区间[left, right)是没有意义的
- if (nums[middle] > target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]



**总结：开区间不用对mid做加减，闭区间需要**



力扣题目

[704. 二分查找](https://leetcode.cn/problems/binary-search/)

[35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/)

[34. 在排序数组中查找元素的第一个和最后一个位置（）两个二分查找找左边界右边界](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)
**写两个二分分别找左边界和右边界**

```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) 
    {
    int first = findFirstPosition(nums, target);
    int last = findLastPosition(nums, target);
    
    if (first <= last) {
        return {first, last};
    } else {
        return {-1, -1};
    }
    }

private:
   int findFirstPosition(std::vector<int>& nums, int target) 
{
    int left = 0;
    int right = nums.size() - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return left;
}

int findLastPosition(std::vector<int>& nums, int target) 
{
    int left = 0;
    int right = nums.size() - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] <= target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return right;
}

};
```

[69. x 的平方根 ](https://leetcode.cn/problems/sqrtx/)

按左闭右开算

### 2、移除元素

**重点：双指针**

**原地移除元素**

[27. 移除元素](https://leetcode.cn/problems/remove-element/)

[26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

[283. 移动零](https://leetcode.cn/problems/move-zeroes/)

```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) 
    {
        int slow=0;
        for(int fast =0;fast<nums.size();fast++)
        {
            if(nums[fast]!=0)
            {
                nums[slow++]=nums[fast];
            }
        }
        for(int fast=slow;fast<nums.size();fast++)
        {
            nums[fast]=0;
        }    

    }
};
```

### 3、有序数组的平方

[977. 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)



### 4、长度最小的子数组（滑动窗口）

[209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

所谓滑动窗口，**就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果**。

```c++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) 
    {
        int i=0;
        int result = INT32_MAX;//INT32_MAX 是一个宏定义，表示 int 类型的最大值。
        int sum=0;// 滑动窗口数值之和
        int len=0;// 滑动窗口长度
        for(int j=0;j<nums.size();j++)
        {   
            sum+=nums[j];
            while(sum>=target)
            {
                len=j-i+1;// 取子序列的长度
                result=min(result,len);
                sum-=nums[i++]; // 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）
            }
        
        }
        // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列
        return result == INT32_MAX ? 0 : result;
    }
};
```



### 5、螺旋矩阵（不会==）



## 链表

### 链表的定义

```c++
//单链表
struct ListNode{
    int val;// 节点上存储的元素
    ListNode *next;// 指向下一个节点的指针
    ListNode(int x):val(x),next(NULL){}// 节点的构造函数
}
```

### 删除节点

![image-20240228103012346](C:\Users\tlc\AppData\Roaming\Typora\typora-user-images\image-20240228103012346.png)

### 添加节点

![image-20240228103027608](C:\Users\tlc\AppData\Roaming\Typora\typora-user-images\image-20240228103027608.png)

### 1、移除链表元素

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) 
    {
        //先创建虚拟节点
        ListNode *cur=new ListNode(0);
        cur->next=head;
        ListNode *fast=cur->next;
        ListNode *slow=cur;
        while(fast!=NULL)
        {
            if(fast->val==val)
            {
                slow->next=fast->next;
                fast=fast->next;
            }
            else
            {
                fast=fast->next;
                slow=slow->next;
            }
        }
        return cur->next;
    }
};
```



### 2、删除链表的倒数第N个结点

[19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

思路：用双指针，快指针先到第N个位置，然后在一起移动,这样慢指针就能到倒数第N个结点位置了

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        if(head==nullptr)return nullptr;

        ListNode *cur=new ListNode(0);
        cur -> next = head;
        ListNode *fast = cur;
        ListNode *slow = cur;

        for (int i = 0; i < n && fast != nullptr; i++) {
            fast = fast->next;
        }
        while (fast->next != nullptr) {
            fast = fast->next;
            slow = slow->next;
        }

        slow->next=slow->next->next;
        return cur->next;
    }
};
```

### 3、翻转链表

[206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

思路：如果再定义一个新的链表，实现链表元素的反转，其实这是对内存空间的浪费。

其实只需要改变链表的next指针的指向，直接将链表反转 ，而不用重新定义一个新的链表，如图所示:

![image-20240228155811639](C:\Users\tlc\AppData\Roaming\Typora\typora-user-images\image-20240228155811639.png)

```c++
class Solution {
public:
    ListNode* reverseList(ListNode* head) 
    {
        ListNode *cur=head;
        ListNode *tmp;
        ListNode *p=NULL;
        while(cur!=nullptr)
        {   
            tmp=cur->next;
            cur->next=p;
            p=cur;
            cur=tmp;
        }
        return p;
    }
};
```



### 4、两两交换链表中的结点

[24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)

![image-20240228161806081](C:\Users\tlc\AppData\Roaming\Typora\typora-user-images\image-20240228161806081.png)

![image-20240228162946473](C:\Users\tlc\AppData\Roaming\Typora\typora-user-images\image-20240228162946473.png)

```c++
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode* dummyHead = new ListNode(0); // 设置一个虚拟头结点
        dummyHead->next = head; // 将虚拟头结点指向head，这样方便后面做删除操作
        ListNode* cur = dummyHead;
        while(cur->next != nullptr && cur->next->next != nullptr) {
            ListNode* tmp = cur->next; // 记录临时节点
            ListNode* tmp1 = cur->next->next->next; // 记录临时节点

            cur->next = cur->next->next;    // 步骤一
            cur->next->next = tmp;          // 步骤二
            cur->next->next->next = tmp1;   // 步骤三

            cur = cur->next->next; // cur移动两位，准备下一轮交换
        }
        return dummyHead->next;
    }
};
```



## 哈希表

###  常见的三种哈希结构

当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。

- 数组

- set （集合）

- map(映射)

  
  ![image-20240228222655359](C:\Users\tlc\AppData\Roaming\Typora\typora-user-images\image-20240228222655359.png)

### 1、有效的字母异位词

[242. 有效的字母异位词](https://leetcode.cn/problems/valid-anagram/)

```c++
class Solution {
public:
    bool isAnagram(string s, string t) 
    {
        unordered_map<char,int>s_count,t_count;
        for(char c:s)
        {
            s_count[c]++;
        }
        for(char c:t)
        {
            t_count[c]++;
        }
        return s_count==t_count;
    }
};
```



### 2.两个数组的交集

哈希表 unordered_map

```c++
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) 
    {
        unordered_map<int,int> s;
        vector<int>result;
        for(int num:nums1)
        {
            s[num]++;
        }
        for(int num:nums2)
        {
            if(s[num]>0)
            {
                result.push_back(num);
                s[num]=0;
            }
        }
        return result;

    }
};
```

[350. 两个数组的交集 II](https://leetcode.cn/problems/intersection-of-two-arrays-ii/)



### 3、两数之和（用哈希表方法的没懂）

[1. 两数之和](https://leetcode.cn/problems/two-sum/)

**map用来存放遍历过的元素**

```
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        std::unordered_map <int,int> map;
        for(int i = 0; i < nums.size(); i++) {
            // 遍历当前元素，并在map中寻找是否有匹配的key
            auto iter = map.find(target - nums[i]); 
            if(iter != map.end()) {
                return {iter->second, i};
            }
            // 如果没找到匹配对，就把访问过的元素和下标加入到map中
            map.insert(pair<int, int>(nums[i], i)); 
        }
        return {};
    }
};
```



### 4、赎金信

[383. 赎金信](https://leetcode.cn/problems/ransom-note/)

### 5、三数之和

[15. 三数之和](https://leetcode.cn/problems/3sum/)



## 字符串

[344. 反转字符串](https://leetcode.cn/problems/reverse-string/)

[541. 反转字符串 II](https://leetcode.cn/problems/reverse-string-ii/)



## 双指针法

[27. 移除元素](https://leetcode.cn/problems/remove-element/)

[344. 反转字符串](https://leetcode.cn/problems/reverse-string/)







## 栈与队列 stack queque

### 理论基础

![image-20240229201609826](C:\Users\13995\AppData\Roaming\Typora\typora-user-images\image-20240229201609826.png)

所以STL中栈往往不被归类为容器，而被归类为container adapter（容器适配器）。



### 1.用栈实现队列

[232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)


![image-20240301214704007](C:\Users\BT7274\AppData\Roaming\Typora\typora-user-images\image-20240301214704007.png)

```c++
class MyQueue {
public:
    stack<int>In;
    stack<int>Out;
    MyQueue() {

    }
    
    void push(int x) {
        In.push(x);
    }
    
    int pop() {
        if(Out.empty())
        {
            while(!In.empty())
            {   
                Out.push(In.top());
                In.pop();
            }
        }
        int result = Out.top();
        Out.pop();
        return result;
    }
    
    int peek() {
        int res = this->pop(); // 直接使用已有的pop函数
        Out.push(res); // 因为pop函数弹出了元素res，所以再添加回去
        return res;
    }
    
    bool empty() {
        return In.empty() && Out.empty();
    }
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj = new MyQueue();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->peek();
 * bool param_4 = obj->empty();
 */
```



### 2.用队列实现栈

[225. 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)

![image-20240301221859314](C:\Users\BT7274\AppData\Roaming\Typora\typora-user-images\image-20240301221859314.png)



**两个队列实现**

```c++
class MyStack {
public:
    queue<int> que1;
    queue<int> que2; // 辅助队列，用来备份
    /** Initialize your data structure here. */
    MyStack() {

    }

    /** Push element x onto stack. */
    void push(int x) {
        que1.push(x);
    }

    /** Removes the element on top of the stack and returns that element. */
    int pop() {
        int size = que1.size();
        size--;
        while (size--) { // 将que1 导入que2，但要留下最后一个元素
            que2.push(que1.front());
            que1.pop();
        }

        int result = que1.front(); // 留下的最后一个元素就是要返回的值
        que1.pop();
        que1 = que2;            // 再将que2赋值给que1
        while (!que2.empty()) { // 清空que2
            que2.pop();
        }
        return result;
    }

    /** Get the top element. */
    int top() {
        return que1.back();
    }

    /** Returns whether the stack is empty. */
    bool empty() {
        return que1.empty();
    }
};
```

#### 优化

其实这道题目就是用一个队列就够了。

**一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时再去弹出元素就是栈的顺序了。**

```c++
class MyStack {
public:
    queue<int> que;
    /** Initialize your data structure here. */
    MyStack() {

    }
    /** Push element x onto stack. */
    void push(int x) {
        que.push(x);
    }
    /** Removes the element on top of the stack and returns that element. */
    int pop() {
        int size = que.size();
        size--;
        while (size--) { // 将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部
            que.push(que.front());
            que.pop();
        }
        int result = que.front(); // 此时弹出的元素顺序就是栈的顺序了
        que.pop();
        return result;
    }

    /** Get the top element. */
    int top() {
        return que.back();
    }

    /** Returns whether the stack is empty. */
    bool empty() {
        return que.empty();
    }
};
```



### 3.有效括号

**stack**

**由于栈结构的特殊性，非常适合做对称匹配类的题目。**

```c++
class Solution {
public:
    bool isValid(string s) 
    {  
        stack<char> stack;
        for(char c:s)
        {
            if(c == '{' || c == '[' || c == '(')
            {
                stack.push(c);
            }
            else if(c=='}'||c==']'||c==')')
            {
                if(stack.empty())
                {
                    return false;
                }
                char top=stack.top();
                stack.pop();
                if (c == '}'&&top!='{'|| c == ')' && top != '('|| c == ']' && top != '[')
                {
                    return false;
                }
            }
        }
    return stack.empty();
    }
};
```



## 二叉树 TreeNode*（重要）搞懂递归三部曲

- 我觉得树的递归大部分都可以这么套路的解决，相当于一个解题模版（初学数据结构的菜鸡
- 模版一共三步，就是**递归的三部曲**：

1. 找终止条件：什么时候递归到头了？此题自然是root为空的时候，空树当然是平衡的。
2. 思考返回值，每一级递归应该向上返回什么信息？参考我代码中的注释。
3. 单步操作应该怎么写？因为递归就是大量的调用自身的重复操作，因此从宏观上考虑，只用想想单步怎么写就行了，左树和右树应该看成一个整体，即此时树一共三个节点：root，root.left，root.right。



**介绍**

[关于二叉树，你该了解这些！| 二叉树理论基础一网打尽，二叉树的种类、二叉树的存储方式、二叉树节点定义、二叉树的遍历顺序_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Hy4y1t7ij/?vd_source=ab1c506999c45afa254a9def770c2d68)

**二叉树的定义**

```c++
struct TreeNode
{
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x):val(x),left(NULL),right(NULL){}
}
```

**说到二叉树，就不得不说递归，很多同学对递归都是又熟悉又陌生，递归的代码一般很简短，但每次都是一看就会，一写就废**。



### 1. 二叉树的递归遍历

这里帮助大家确定下来递归算法的三个要素。**每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！**

1. **确定递归函数的参数和返回值：** 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
2. **确定终止条件：** 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
3. **确定单层递归的逻辑：** 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。



**前序遍历**

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void qianxu(TreeNode *root,vector<int>& s)//递归三要素 1.确定函数的传入值和返回值
    {   
        if(root==nullptr)return;//2.确定终止条件
        //3.确定递归逻辑
        s.push_back(root->val);
        qianxu(root->left,s);
        qianxu(root->right,s);

    }
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> s;
        qianxu(root,s);
        return s;
    }
};
```



**中序遍历**

```c++
class Solution {
public:
    void inorderTraversal(TreeNode* root,vector<int>& num)
    {
        if(root==nullptr)return;
        inorderTraversal(root->left,num);
        num.push_back(root->val);
        inorderTraversal(root->right,num);

    }
    vector<int> inorderTraversal(TreeNode* root) 
    {   
        vector<int> num;
        inorderTraversal(root,num);
        return num;

    }
};

```

**后序遍历**

```c++
class Solution {
public:
  void postorderTraversal(TreeNode* root,vector<int>& num)
    {
        if(root==nullptr)return;
        postorderTraversal(root->left,num);
        postorderTraversal(root->right,num);
        num.push_back(root->val);

    }
    vector<int> postorderTraversal(TreeNode* root) 
    {
        vector<int>num;
        postorderTraversal(root,num);
        return num;
    }
};

```





### 2.二叉树的层序遍历

[102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

需要借用一个辅助数据结构即队列来实现，**队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。**

这样就实现了层序从左到右遍历二叉树。

代码如下：**这份代码也可以作为二叉树层序遍历的模板，打十个就靠它了**。

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        vector<vector<int>> result;
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                vec.push_back(node->val);
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(vec);
        }
        return result;
    }
};
```



[107. 二叉树的层序遍历 II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)

**思路**

相对于102.二叉树的层序遍历，就是最后把result数组反转一下就可以了。



[199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

**思路**

层序遍历的时候，判断是否遍历到单层的最后面的元素，如果是，就放进result数组中，随后返回result就可以了。



[637. 二叉树的层平均值 - 力扣（LeetCode）](https://leetcode.cn/problems/average-of-levels-in-binary-tree/description/)

**思路**

本题就是层序遍历的时候把一层求个总和在取一个均值



### 3.翻转二叉树

https://leetcode.cn/problems/invert-binary-tree/

遍历的过程中去翻转每一个节点的左右孩子就可以达到整体翻转的效果。

**注意只要把每一个节点的左右孩子翻转一下，就可以达到整体翻转的效果**

**这道题目使用前序遍历和后序遍历都可以，唯独中序遍历不方便，因为中序遍历会把某些节点的左右孩子翻转了两次！建议拿纸画一画，就理解了**

```c++
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) 
    {   
         //终止条件
        if(root==nullptr)return root;
        swap(root->left,root->right);
        invertTree(root->left);
        invertTree(root->right);
        return root;
    }
};
```





### 4.二叉树最大深度

https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/

```c++
class Solution {
public:
    int travelmax(TreeNode* root)
    {   
        if(root==NULL)return 0;
        int leftnum=travelmax(root->left);
        int rightnum=travelmax(root->right);
        int maxnum=1+max(leftnum,rightnum);
        return maxnum;

    }
    int maxDepth(TreeNode* root) 
    {   
       return  travelmax(root);
    }
};
```

**而根节点的高度就是二叉树的最大深度**，所以本题中我们通过后序求的根节点高度来求的二叉树最大深度。

**确定单层递归的逻辑：先求它的左子树的深度，再求右子树的深度，最后取左右深度最大的数值 再+1 （加1是因为算上当前中间节点）就是目前节点为根节点的树的深度。**



#### **N叉树最大深度**

**知道什么是N叉树，知道怎么定义**

https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    int maxDepth(Node* root) 
    {
        if(root==NULL)return 0;
        int Depth=0;
        for(int i=0;i<root->children.size();i++)
        {
            Depth=max(Depth,maxDepth(root->children[i]));

        }
        return Depth+1;
    }
};
```



### 5.完全二叉树的节点个数（没懂）

**什么是完全二叉树**

在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^(h-1)  个节点。

[要理解普通二叉树和完全二叉树的区别！ | LeetCode：222.完全二叉树节点的数量](https://leetcode.cn/link/?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1eW4y1B7pD)

[222. 完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/)



**以下是普通二叉树的节点个数代码（遍历法）（没用到完全二叉树的性质，但是也能用来计算完全二叉树的）**

```c++
class Solution {
public:
    int countNodes(TreeNode* root) 
    {
        if(root==NULL)return 0;
        int leftnum=countNodes(root->left);
        int rightnum=countNodes(root->right);
        return 1+rightnum+leftnum;
    }
};
```





### 6.对称二叉树

[101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)



1. 确定终止条件

要比较两个节点数值相不相同，首先要把两个节点为空的情况弄清楚！否则后面比较数值的时候就会操作空指针了。

节点为空的情况有：（**注意我们比较的其实不是左孩子和右孩子，所以如下我称之为左节点右节点**）

- 左节点为空，右节点不为空，不对称，return false
- 左不为空，右为空，不对称 return false
- 左右都为空，对称，返回true

此时已经排除掉了节点为空的情况，那么剩下的就是左右节点不为空：

- 左右都不为空，比较节点数值，不相同就return false

  
  

**盲目的照着抄，结果就是：发现这是一道“简单题”，稀里糊涂的就过了，但是真正的每一步判断逻辑未必想到清楚。**

```c++
class Solution {
public:
    bool compare(TreeNode*left,TreeNode*right)
    {
        if (left == NULL && right != NULL) return false;
        else if (left != NULL && right == NULL) return false;
        else if (left == NULL && right == NULL) return true;
        else if(left->val!=right->val) return false;
        else 
        {
            bool outside = compare(left->left, right->right);   // 左子树：左、 右子树：右
            bool inside = compare(left->right, right->left);    // 左子树：右、 右子树：左
            bool isduicheng=(outside&&inside);
            return isduicheng;
        }
    }

    bool isSymmetric(TreeNode* root) 
    {
        if(root==NULL)return 0;
        return compare(root->left,root->right);
    }
};
```



### 7.二叉树的最小深度(要理解啥意思)

https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/

所以，如果左子树为空，右子树不为空，说明最小深度是 1 + 右子树的深度。

反之，右子树为空，左子树不为空，最小深度是 1 + 左子树的深度。 最后如果左右子树都不为空，返回左右子树深度最小值 + 1 。

```c++
class Solution {
public:
    int mintravel(TreeNode* root)
    {
        if(root==NULL)return 0;
        int leftth=mintravel(root->left);
        int rightth=mintravel(root->right);
        
        // 当一个左子树为空，右不为空，这时并不是最低点
        if (root->left == NULL && root->right != NULL) { 
            return 1 + rightth;
        }   
        // 当一个右子树为空，左不为空，这时并不是最低点
        if (root->left != NULL && root->right == NULL) { 
            return 1 + leftth;
        }
        return 1+min(leftth,rightth);
    }

    int minDepth(TreeNode* root) 
    {
        return mintravel(root);
    }
};
```



### 8.平衡二叉树(云里雾里，看答案能看懂)

https://leetcode.cn/problems/balanced-binary-tree/description/



```c++
class Solution {
public:
    int getHeight(TreeNode* root) {
        if (root == NULL) return 0;
        int leftHeight = getHeight(root->left);
        int rightHeight = getHeight(root->right);
        return 1 + max(leftHeight, rightHeight);
    }

    bool isBalanced(TreeNode* root) {
        if (root == NULL) return true;
        
        int leftHeight = getHeight(root->left);
        int rightHeight = getHeight(root->right);
        
        if (abs(leftHeight - rightHeight) > 1) {
            return false;
        }
        
        return isBalanced(root->left) && isBalanced(root->right);
    }
};
```



### 9.二叉树的所有路径（建议多刷几遍）----递归+回溯的题要熟悉

https://leetcode.cn/problems/binary-tree-paths/description/

**要知道递归和回溯就是一家的，本题也需要回溯。**

**回溯和递归是一一对应的，有一个递归，就要有一个回溯**





```c++
class Solution {
public:
    
    void travel(TreeNode* root,vector<int>& path,vector<string>& result)
    {   
        path.push_back(root->val);//放最前面，因为最后一个节点也要加入进去
        if(root->left==NULL&&root->right==NULL)
        {   
            
            string sPath;
            for (int i = 0; i < path.size() - 1; i++) {
                sPath += to_string(path[i]);
                sPath += "->";
            }
            sPath += to_string(path[path.size() - 1]);
            result.push_back(sPath);
            return;
        }
        if(root->left)
        {
            travel(root->left,path,result);
            path.pop_back();// 回溯
        }
        if(root->right)
        {
            travel(root->right,path,result);
            path.pop_back();// 回溯
        }


    }
    vector<string> binaryTreePaths(TreeNode* root) 
    {
        vector<int>path;
        vector<string>result;
        travel(root,path,result);
        return result;

    }
};
```

**精简代码**

```c++
class Solution {
public:
    void dfs(TreeNode* root,string path,vector<string>& result)
    {
        path += to_string(root->val);
        if(root->left==NULL&&root->right==NULL)
        {
            result.push_back(path);
            return ;
        }
        if(root->left)
        {
            dfs(root->left,path+"->",result);
        }
        if(root->right)
        {
            dfs(root->right,path+"->",result);
        }

    }

    vector<string> binaryTreePaths(TreeNode* root) 
    {
        string path;
        vector<string>result;
        dfs(root,path,result);
        return result;
    }
};
```

如上代码精简了不少，也隐藏了不少东西。

注意在函数定义的时候`void traversal(TreeNode* cur, string path, vector<string>& result)` ，定义的是`string path`，每次都是复制赋值，不用使用引用，否则就无法做到回溯的效果。（这里涉及到C++语法知识）

那么在如上代码中，**貌似没有看到回溯的逻辑，其实不然，回溯就隐藏在`traversal(cur->left, path + "->", result);`中的 `path + "->"`。** 每次函数调用完，path依然是没有加上"->" 的，这就是回溯了。

#### 拓展

这里讲解本题解的写法逻辑以及一些更具体的细节，下面的讲解中，涉及到C++语法特性，如果不是C++的录友，就可以不看了，避免越看越晕。

如果是C++的录友，建议本题独立刷过两遍，再看下面的讲解，同样避免越看越晕，造成不必要的负担。

在第二版本的代码中，其实仅仅是回溯了 `->` 部分（调用两次pop_back，一个pop`>` 一次pop`-`），大家应该疑惑那么 `path += to_string(cur->val);` 这一步为什么没有回溯呢？ 一条路径能持续加节点 不做回溯吗？

其实关键还在于 参数，使用的是 `string path`，这里并没有加上引用`&` ，即本层递归中，path + 该节点数值，但该层递归结束，上一层path的数值并不会受到任何影响。 如图所示：

![](/home/sbim/cpplearn/CPP/pic/screenshot-20240308-105322.png)

节点4 的path，在遍历到节点3，path+3，遍历节点3的递归结束之后，返回节点4（回溯的过程），path并不会把3加上。

所以这是参数中，不带引用，不做地址拷贝，只做内容拷贝的效果。（这里涉及到C++引用方面的知识）

**例子**

假设我们有以下二叉树：

```
    1
   / \
  2   3
   \
    5
```

首先，我们从根节点1开始进行深度优先搜索（DFS）：

1. 当前节点是1，路径为"1"。
2. 继续向左子节点2遍历：
   - 当前节点是2，路径更新为"1->2"。
   - 由于2没有左右子节点，将路径"1->2"加入结果中。
3. 回到节点1，继续向右子节点3遍历：
   - 当前节点是3，路径更新为"1->3"。
   - 继续向下遍历右子节点5：
     - 当前节点是5，路径更新为"1->3->5"。
     - 由于5没有左右子节点，将路径"1->3->5"加入结果中。
4. 遍历完成，结果为["1->2", "1->3->5"]。

这样，通过深度优先搜索和回溯的方式，我们可以得到所有从根节点到叶子节点的路径。



### 10.左叶子之和

![image-20240309111543278](/home/sbim/.config/Typora/typora-user-images/image-20240309111543278.png)

```c++

class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) 
    {	
        //终止条件
        if(root==NULL)return 0;

        int leftnum=0;
        //单层逻辑
        //判断左叶子逻辑
        if(root->left&&!root->left->left&&!root->left->right)
        {
            leftnum+=root->left->val;
        }
        else
        {
            leftnum+=sumOfLeftLeaves(root->left);
        }    
        int rightnum =sumOfLeftLeaves(root->right);

        return rightnum+leftnum;
    }
};
```

这道题目要求左叶子之和，其实是比较绕的，因为不能判断本节点是不是左叶子节点。

此时就要通过节点的父节点来判断其左孩子是不是左叶子了。

**平时我们解二叉树的题目时，已经习惯了通过节点的左右孩子判断本节点的属性，而本题我们要通过节点的父节点判断本节点的属性。**





### 11.找树左下角的值

https://leetcode.cn/problems/find-bottom-left-tree-value/description/

给定一个二叉树，在树的最后一行找到最左边的值。



**迭代写法**

```c++
 //层序遍历稍作修改做
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) 
    {
        queue<TreeNode*>que;
        if(root!=NULL)que.push(root);
        int result=0;
        while(!que.empty())
        {
            int size=que.size();
            for(int i=0;i<size;i++)
            {
                TreeNode* node=que.front();
                que.pop();
                if (i == 0) result = node->val; // 记录最后一行第一个元素
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
        }
        return result;
    }
};
```

这段代码实现了一个函数 `findBottomLeftValue`，用于找到二叉树最底层最左边的节点的值。下面我会举个例子来解释这个算法的流程：

假设我们有如下的二叉树：

```
    2
   / \
  1   3
 /     \
4       5
```

首先，我们将根节点 `2` 加入队列中，然后进入循环。在第一次循环时，队列中有一个节点 `2`，我们取出这个节点，记录其值为 `result`，即 `2`。然后将其左右子节点加入队列：左子节点 `1` 和右子节点 `3`。

在第二次循环时，队列中有 `1` 和 `3` 两个节点，先取出节点 `1`，由于它是当前层的第一个节点（即最左边的节点），所以更新 `result` 为 `1`。然后将 `1` 的子节点 `4` 加入队列。接着取出节点 `3`，将其子节点 `5` 加入队列。

在第三次循环时，队列中有 `4` 和 `5` 两个节点，取出 `4`，由于它是当前层的第一个节点，更新 `result` 为 `4`。然后队列为空，循环结束。

最终返回的 `result` 值为 `4`，即二叉树最底层最左边的节点的值。



**递归写法（不是很懂）**

```c++
class Solution {
public:
    int maxDepth = INT_MIN;
    int result;
    void traversal(TreeNode* root, int depth) {
        if (root->left == NULL && root->right == NULL) {
            if (depth > maxDepth) {
                maxDepth = depth;
                result = root->val;
            }
            return;
        }
        if (root->left) {
            traversal(root->left, depth + 1); // 隐藏着回溯
        }
        if (root->right) {
            traversal(root->right, depth + 1); // 隐藏着回溯
        }
        return;
    }
    int findBottomLeftValue(TreeNode* root) {
        traversal(root, 0);
        return result;
    }
};
```



### 12.合并二叉树

https://leetcode.cn/problems/merge-two-binary-trees/

相信这道题目很多同学疑惑的点是如何同时遍历两个二叉树呢？

其实和遍历一个树逻辑是一样的，只不过传入两个树的节点，同时操作。

```c++

class Solution {
public:

    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) 
    {
        if (root1 == NULL) return root2; // 如果t1为空，合并之后就应该是t2
        if (root2 == NULL) return root1; // 如果t2为空，合并之后就应该是t1

        root1->val+=root2->val;
        root1->left=mergeTrees(root1->left,root2->left);
        root1->right=mergeTrees(root1->right,root2->right);
        return root1;
    }
};
```



### 13.二叉搜索树中的搜索

https://leetcode.cn/problems/search-in-a-binary-search-tree/

**简单题，迭代法比递归简单**

**迭代法**

```c++
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        if (root == NULL || root->val == val) return root;
        if (root->val > val) return searchBST(root->left, val);
        if (root->val < val) return searchBST(root->right, val);
        return NULL;
    }
};
```



**递归法**

```c++
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        while (root != NULL) {
            if (root->val > val) root = root->left;
            else if (root->val < val) root = root->right;
            else return root;
        }
        return NULL;
    }
};
```



### 14.验证二叉搜索树(二叉搜索树是左子树所有节点小于中间节点，右子树所有节点大于中间节点)

**我写的构式代码---大错特错==**

```c++
我写的构式代码---大错特错==xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
class Solution {
public:
    bool isBST(TreeNode* l,TreeNode* r,int val)
    {
        if (l->val>=val) return false;
        else if (r->val<=val) return false;
        
        isBST(l->left,l->right,l->val);
        isBST(r->left,r->right,r->val);
		return true;

    }
    bool isValidBST(TreeNode* root) 
    {
        if (root == NULL ) return false;
        return isBST(root->left,root->right,root->val);
    }
};xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
```



**你的代码存在几个问题：**

1. 二叉搜索树的验证不只是检查当前节点与其直接子节点；这需要一个上下界来确保所有左子树的节点均小于当前节点的值，所有右子树节点均大于当前节点的值。

2. 你的`isBST`函数的原型和逻辑似乎不太对，传递左子树和右子树作为参数，也传递值会引起混淆，并不需要将右子树作为参数传入。

3. 你并没有使用递归的返回值。

以下是修改后的代码：

```cpp
class Solution {
public:
    bool isBST(TreeNode* node,long long lower,long long upper){
        if(node == NULL) return true;

        int val = node->val;
        if(val <= lower || val >= upper) return false;

        if(!isBST(node->left, lower, val)){
            return false;
        }
        if(!isBST(node->right, val, upper)){
            return false;
        }
        return true;
    }

    bool isValidBST(TreeNode* root) {
        return isBST(root, LLONG_MIN, LLONG_MAX);
    }
};
```

代码做了以下改动：

- `isBST`函数接收当前节点以及允许值的上下界（使用`long long`来处理可能的整数边界问题）。
- `isBST`先验证当前节点的值和上下界的关系。
- 再递归的分别检查左子树和右子树，左子树值的上界是当前节点的值，右子树值的下界也是当前节点的值。
- `Validity`检查起始调用时对root使用整数最小值和最大值作为初始上下界。
- 根节点为空树被认为是有效的二叉搜索树，所以如果`root`为空，你应该返回`true`而不是`false`。



**还有个思路：**

#### 思路

要知道中序遍历下，输出的二叉搜索树节点的数值是有序序列。

有了这个特性，**验证二叉搜索树，就相当于变成了判断一个序列是不是递增的了。**

**递归法**

可以递归中序遍历将二叉搜索树转变成一个数组，代码如下：

```cpp
vector<int> vec;
void traversal(TreeNode* root) {
    if (root == NULL) return;
    traversal(root->left);
    vec.push_back(root->val); // 将二叉搜索树转换为有序数组
    traversal(root->right);
}
```

然后只要比较一下，这个数组是否是有序的，**注意二叉搜索树中不能有重复元素**。

```cpp
traversal(root);
for (int i = 1; i < vec.size(); i++) {
    // 注意要小于等于，搜索树里不能有相同元素
    if (vec[i] <= vec[i - 1]) return false;
}
return true;
```

整体代码如下：

```cpp
class Solution {
private:
    vector<int> vec;
    void traversal(TreeNode* root) {
        if (root == NULL) return;
        traversal(root->left);
        vec.push_back(root->val); // 将二叉搜索树转换为有序数组
        traversal(root->right);
    }
public:
    bool isValidBST(TreeNode* root) {
        vec.clear(); // 不加这句在leetcode上也可以过，但最好加上
        traversal(root);
        for (int i = 1; i < vec.size(); i++) {
            // 注意要小于等于，搜索树里不能有相同元素
            if (vec[i] <= vec[i - 1]) return false;
        }
        return true;
    }
};
```

以上代码中，我们把二叉树转变为数组来判断，是最直观的，但其实不用转变成数组，可以在递归遍历的过程中直接判断是否有序。



### 15.二叉搜索树的最小绝对差

https://leetcode.cn/problems/minimum-absolute-difference-in-bst/

自己做出来的hh

```c++
class Solution {
public:
    vector<int>v;
    void travel(TreeNode* root)
    {
        if(root==nullptr)return ;
        travel(root->left);
        v.push_back(root->val);
        travel(root->right);
    }

    int getMinimumDifference(TreeNode* root) 
    {
        travel(root);
        int result=INT_MAX;
        for(int i=1;i<v.size();i++)
        {
            int diff=abs(v[i]-v[i-1]);
            result = min(diff,result);
        }
        return result;
        
    }
};
```

**遇到在二叉搜索树上求什么最值，求差值之类的，都要思考一下二叉搜索树可是有序的，要利用好这一特点。**



## 贪心算法

### 1.分饼干

[455. 分发饼干 - 力扣（LeetCode）](https://leetcode.cn/problems/assign-cookies/submissions/512459645/)

**思路**

为了满足更多的小孩，就不要造成饼干尺寸的浪费。

大尺寸的饼干既可以满足胃口大的孩子也可以满足胃口小的孩子，那么就应该优先满足胃口大的。

**这里的局部最优就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩**。

```c++
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) 
    {   
        sort(g.begin(),g.end());
        sort(s.begin(),s.end());

        int result=0;
        int index =s.size()-1;
        for(int i=g.size()-1;i>=0;i--)
        {
            if(index>=0&&s[index]>=g[i])
            {
                result++;
                index --;
            }
        }
        return result;


    }
};
```

### 2.最大子数和

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) 
    {
        int sum=nums[0];
        int cnt=nums[0];
        for(int i=1;i<nums.size();i++)
        {
            cnt = max(cnt+nums[i],nums[i]);
            sum=max(sum,cnt);
        }
        return sum;
    }
};
```



这段代码是实现了著名的Kadane算法，用于解决最大子数组和的问题。这个问题的目标是在一个整数数组中找到一个具有最大和的连续子数组（至少包含一个数），并返回其最大和。

让我们通过一个例子来说明这个算法的流程：

假设我们有以下数组：

```
nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
```

初始化`sum`和`cnt`为数组的第一个元素`nums[0]`，即`-2`。这里`sum`记录当前找到的最大子数组和，而`cnt`记录遍历到当前元素为止的最大子数组和。

1. **开始遍历数组**从索引`1`开始，即数字`1`。
   - 计算`cnt = max(-2 + 1, 1)`，得到`cnt = 1`。
   - 更新`sum = max(-2, 1)`，得到`sum = 1`。
2. **遍历到`-3`**：
   - `cnt = max(1 - 3, -3)`，得到`cnt = -2`。
   - `sum = max(1, -2)`，`sum`保持不变为`1`。
3. **遍历到`4`**：
   - `cnt = max(-2 + 4, 4)`，得到`cnt = 4`。
   - `sum = max(1, 4)`，更新`sum = 4`。



## 动态规划

### **基础题目**

### 1.斐波那契数

```cpp
class Solution {
public:
    int fib(int N) {
        if (N <= 1) return N;
        vector<int> dp(N + 1);
        dp[0] = 0;
        dp[1] = 1;
        for (int i = 2; i <= N; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[N];
    }
};
```

**递归解法**

```cpp
class Solution {
public:
    int fib(int N) {
        if (N < 2) return N;
        return fib(N - 1) + fib(N - 2);
    }
};
```



### 2.爬楼梯

```cpp
class Solution {
public:
    int climbStairs(int n) 
    {

        if(n==1) return 1;
        if(n==2) return 2;
        int p[n+1];
        p[1]=1;
        p[2]=2;
        p[0]=0;
        for(int i=3;i<=n;i++)
        {
            p[i]=p[i-1]+p[i-2];
        }
        return p[n];
    }
};
```



### 3.[使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)

```cpp
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) 
    {   
        int n=cost.size();
        if(n<2)return 0;
        vector<int> p(n+1);
        p[0]=0;
        p[1]=0;

        for(int i=2;i<=n;i++)
        {
            p[i]=min(p[i-1]+cost[i-1],p[i-2]+cost[i-2]);

        }
        return p[n];
    }
};
```

### 4. 不同路径

[62. 不同路径 - 力扣（LeetCode）](https://leetcode.cn/problems/unique-paths/submissions/)

### 5. 不同路径二 （有障碍物）

[63. 不同路径 II](https://leetcode.cn/problems/unique-paths-ii/)



```cpp
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) 
    {   
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
        if (obstacleGrid[m - 1][n - 1] == 1 || obstacleGrid[0][0] == 1) //如果在起点或终点出现了障碍，直接返回0
            return 0;
        vector<vector<int>> p(m,vector<int>(n,0));
        //初始化 除了障碍都为1
        for(int i=0;i<m && obstacleGrid[i][0] == 0;i++)p[i][0]=1;
        for(int j=0;j<n && obstacleGrid[0][j] == 0;j++)p[0][j]=1;
          for (int i = 1; i < m; i++) 
          {
            for (int j = 1; j < n; j++) 
                {   
                    if (obstacleGrid[i][j] == 1) continue;//遇到障碍跳过
                    p[i][j]=p[i-1][j]+p[i][j-1];
                }
                
            }
            return p[m-1][n-1];
```



### 6.不同的二叉搜索树

https://leetcode.cn/problems/unique-binary-search-trees/description/



**基本思路是：**对于求解 dp[i]，我们可以将每个数字 j (1 <= j <= i) 作为根节点，然后将 1 ... (j-1) 构成的子树的种类数乘上 1 ... (i-j) 构成的子树的种类数，然后累加起来即可。

**举个例子**：

dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量

元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量

元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量

元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量

```cpp
class Solution {
public:
    int numTrees(int n) 
    {
        vector<int> dp(n+1,0);
        dp[0]=1;
        dp[1]=1;

        for(int i=2;i<=n;i++)
        {
            for(int j=1 ;j<=i ;j++)
            {
                dp[i]+=dp[j-1]*dp[i-j];
            }
        }
        return dp[n];
    }
};
```

### 7.整数拆分

**基本思路是**：对于每个正整数 i，我们可以将其拆分为 j 和 i-j，**然后比较这两部分的乘积与它们本身的乘积**，并将最大值保存在 dp[i] 中。最终，dp[n] 就是将正整数 n 拆分后得到的最大乘积。

//基本思路是：对于每个正整数 i，我们可以将其拆分为 j 和 i-j，然后比较这两部分的乘积与它们本身的乘积，并将最大值保存在 dp[i] 中。最终，dp[n] 就是将正整数 n 拆分后得到的最大乘积。

```cpp
//基本思路是：对于每个正整数 i，我们可以将其拆分为 j 和 i-j，然后比较这两部分的乘积与它们本身的乘积，并将最大值保存在 dp[i] 中。最终，dp[n] 就是将正整数 n 拆分后得到的最大乘积。
class Solution {
public:
    int integerBreak(int n) 
    {
        vector<int> dp(n+1,0);
        dp[2]=1;

        for(int i=3;i<=n;i++)
        {
            for(int j=2;j<i;j++)
            {
                dp[i]=max(dp[i],max(j*(i-j),dp[j]*(i-j)));
            }
        }
        return dp[n];
    }
};
```

