

![image-20231026213735786](C:\Users\BT7274\AppData\Roaming\Typora\typora-user-images\image-20231026213735786.png)



![image](https://i0.hdslb.com/bfs/new_dyn/621463249f8c03720b58a98021d6c9f9207333980.png@135w_1s_!web-comment-note.webp)

# 初级算法

## 1.删除链表节点 （很牛的思想）

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    void deleteNode(ListNode* node) 
    { 
        node->val = node->next->val;
        node->next = node->next->next;
    }
};


```



## 2.找出在数组中只出现一次的元素

```c++
class Solution {
    public int singleNumber(int[] nums) {
        int reduce = 0;
        for (int num : nums) {
            reduce =  reduce ^ num;
        }
        return reduce;
    }
}
```

具体解释如下：

1. 初始化一个变量 `reduce` 为0，用来存储最终的结果。
2. 遍历数组中的每个元素 `num`。
3. 将 `reduce` 和 `num` 进行异或运算，结果再赋值给 `reduce`。这个步骤实际上是将数组中所有的元素都进行异或运算，由于异或运算满足交换律和结合律，所以数组中重复出现的元素会两两抵消为0，最后剩下的就是只出现一次的元素。
4. 返回最终的结果 `reduce`，即出现一次的元素。



## 3.移动0到数组末尾

```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) 
    {
    
    int n = nums.size();
    int countZeroes = 0;
    for (int i = 0; i < n; i++) {
        if (nums[i] == 0) {
            countZeroes++;
        } else {
            // 非零元素前移，覆盖零元素的位置
            nums[i - countZeroes] = nums[i];
        }
    }
    
    // 将末尾的 countZeroes 个元素设为零
    for (int i = n - countZeroes; i < n; i++) {
        nums[i] = 0;
    }

};
```

## 4.找出字符串中只出现一次的字符（用哈希表）

```c++
class Solution {
public:
    int firstUniqChar(string s) 
    {
        unordered_map<char, int> charMap;
        
        for (char c : s) 
        {
            charMap[c]++;
            //执行 charMap[c]++，将 charMap['c'] 的计数加1，因此此时 charMap['c'] 的值是1。
        }
        
        for (int i = 0; i < s.size(); i++) {
            if (charMap[s[i]] == 1) {
                return i;
            }
        }
        
        return -1;  // 如果没有找到不重复的字符，则返回-1
    }
};
```

**==**

**把string s数组里面每一个不同的元素放在哈希表中，元素值用key表示，元素出现的次数用value表示，比如：2,3,3这个数组， 哈希表的结构是{{3,2},{2,1}};**

**==**

## 5.合并两个有序数组

输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
解释：需要合并 [1,2,3] 和 [2,5,6] 。
合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。

```
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) 
    {
        int i=m-1;
        int j=n-1;
        int end=n+m-1;
        while(j>=0)
        {
            nums1[end--]=(i>=0&&nums1[i]>nums2[j])?nums1[i--]:nums2[j--];
        }
    }
};
```

**从后往前的顺序进行合并操作**

## 6.最长公共前缀

```c++
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) 
    {   
        if (strs.empty()) 
        {
            return "";
        }
        string s="";
        int len1=strs[0].length();
        int len2=strs.size();
        for(int i=0;i<len1;i++)
        {   
            for(int j=1;j<len2;j++)
            {
                if (i >= strs[j].length() || strs[j][i] != strs[0][i]) 
                {
                    return s;
                }
            }
            s+=strs[0][i];
        }
        return s;
    }
};
```

## 7.加一

给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。

```
class Solution  {
public:
    vector<int> plusOne(vector<int>& digits) {
        for(int i=digits.size()-1; i>=0; i--)
        {
            digits[i]++;
            if(digits[i] == 10)  digits[i] = 0;
            else  return digits;
        }
        digits.insert(digits.begin(), 1);
        return digits;
    }
};
```

```
据给出的代码，对于输入数组[1, 2, 9]，算法会进行逐位加一操作。具体步骤如下：

从数组的最后一个元素开始遍历，即从索引为len-1的位置开始。
将当前元素digits[i]加一，并更新该位置的值。
检查更新后的值是否等于10。如果等于10，说明有进位，则将该位置的值设为0，并继续处理前一位。
如果更新后的值不等于10，说明没有进位，直接返回结果数组digits。
对于输入数组[1, 2, 9]，具体执行过程如下：

初始数组：[1, 2, 9]
对最后一位9进行加一操作，得到：[1, 2, 10]
最后一位为10，需要进位，将其设为0，继续处理前一位。
对第二位2进行加一操作，得到：[1, 3, 0]
第二位不为10，直接返回结果数组：[1, 3, 0]
因此，对于输入数组[1, 2, 9]，算法计算得到的结果是[1, 3, 0]。
```

## 8 买卖股票的最佳时期（很牛）

```c++
class Solution {
public:
//求上升区间的高度和？
    int maxProfit(vector<int>& prices) 
    {
        
        int max=0;
        int n=prices.size();
        if(n<=1)
        {
            return 0;
        }
        for(int i=1;i<n;i++)
        {
            int d=prices[i]-prices[i-1];
            if(d>0)max+=d;

        }
        return max;

    }
};
```

[7,1,2,5,3,8,1,2]

上升区间 为 1-2  2-5  3-8 1-2  算出来为 1+3+5+1=10

## 9 判断质数

```c++
for(int i=2;i*i<=num;i++)
{
    if(num%i==0)
    {
        return false;
    }
}
```

还有个埃氏筛选法

## 10 判断是否为整数 （内置函数）

"floor(a)"是一个数学函数，它返回小于或等于"a"的最大整数值。

```c++
floor(a)==a;  判断a是否为整数
```



## 11 移动零

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

```c++

```



## 12 荷兰国旗问题（颜色分类）  记住是怎么做的

```c++
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int n0 = 0;
        int n1 = 0;
        int n2 = 0;

        for (int num : nums) {
            if (num == 0) {
                n0++;
            } else if (num == 1) {
                n1++;
            } else {
                n2++;
            }
        }

        for (int i = 0; i < nums.size(); i++) {
            if (i < n0) {
                nums[i] = 0;
            } else if (i < n0 + n1) {
                nums[i] = 1;
            } else {
                nums[i] = 2;
            }
        }
    }
};
```

**具体算法如下：**

1. 遍历一遍数组，分别统计出0、1和2的个数n0、n1和n2。
2. 将数组中前n0个位置填充为0，接下来的n1个位置填充为1，最后的n2个位置填充为2。

举一个简单的例子，如果数组nums为[2, 0, 2, 1, 1, 0]，按照上述算法进行排序的过程如下：

1. 遍历一遍数组，统计出n0=2，n1=2，n2=2。
2. 填充数组前2个位置为0，接下来的2个位置为1，最后的2个位置为2。这样得到的结果为[0, 0, 1, 1, 2, 2]。



##  13 对撞指针法 -----两数之和

![image-20231102153825566](C:\Users\BT7274\AppData\Roaming\Typora\typora-user-images\image-20231102153825566.png)

```c++
class Solution {
public:
//双指针：一头一尾指针 
//对撞指针法
    vector<int> twoSum(vector<int>& numbers, int target) {
        int left = 0;
        int right = numbers.size() - 1;

        while (left < right) {
            int sum = numbers[left] + numbers[right];
            if (sum == target) {
                return {left+1, right+1};
            } else if (sum < target) {
                left++;
            } else {
                right--;
            }
        }
        // 没有找到符合要求的两个数
        return {};
    }
};
```

## 14 验证回文串

- **`isalnum()` 函数用于判断一个字符是否为字母或数字。**如果是，则返回 true，否则返回 false。该函数的原型如下：

  ```c++
  int isalnum(int c);
  ```

  其中，c 表示要判断的字符，返回值为整形。

- **`tolower()` 函数用于将大写字母转换为小写字母，如果参数不是大写字母，则直接返回原来的字符。**该函数的原型如下：

  ```c++
  int tolower(int c);
  ```

  其中，c 表示要转换的字符，返回值为整形。

```c++
class Solution {
public:
    //先去除除字母数字外的字符
    bool isPalindrome(string s) 
    {
        string str;
        for(char ch:s)
        {
            if(isalnum(ch))
            {
                str+=tolower(ch);
            }
        }
     //验证回文串 
        string str1=str;
        reverse(str.begin(),str.end());
        return str==str1;

    }
};
```





# 链表

## 1.访问第index个节点

```c++
struct nodelist
{
    int val;
    nodelist *next;
    nodelist(int x):val(x),next(NULL){}
};

int count=0;
nodelist *curr=head;
while(count!=index&&curr!=null)
{
    curr=curr.next;
    count++;
}
if(curr==null)
{
    return -1;
}
return curr.val;


```

## 2.插入

### 2.1 头部插入



```c++
newnode.next=head;
head=newnode;

```

### 2.2 尾部插入

```c++

nodelist *visit=head;
if(head==null)
{
    head=newnode;
}
while(visit.next!=null)
{
    visit=visit.next;
}
visit.next=newnode;
newnode.next=null;


```

### 2.3 在index位置插入

```c++
nodelist *visit=head;
if(head==null)
{
    head=newnode;
}
int count=0;
while(count!=index-1&&visit.next!=null)
{
    visit=visit.next;
    count++;
}
newnode.next=visit.next;
visit.next=newnode;

```

## 反转链表（还不会做。。。）

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
ListNode* prev = nullptr;
        ListNode* curr = head;
        
        while (curr != nullptr) {
            ListNode* next = curr->next;
            curr->next = prev;
            prev = curr;
            curr = next;
        }
        return prev;
    }
};
```





## 3.删除

### 3.1 删除头部节点

```c++
nodelist *curr =head;
head=head.next;
```

### 3.2 删除尾部节点

```c++
nodelist *visit=head;
while(visit.next!==null)
{
    if(visit.next.next==null)
    {
        visit.next==null;
    }
    visit=visit.next;
}

```

### 3.3  删除index处的节点

```c++
nodelist *visit=head;
int count =0;
for(int i=0;i<index-1&&visit.next!=null;i++)
{
    visit=visit.next;
}
visit.next=visit.next.next;

```

### 3.4 删除倒数第n个节点

```c++
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) 
    {
        if (head == nullptr) {
            return nullptr;
        }
        
       //new一个虚拟节点来指向头节点 
        ListNode* dummy = new ListNode(0);/
        dummy->next = head;
        
        ListNode* fast = dummy;
        ListNode* slow = dummy;
        
        for (int i = 0; i < n && fast != nullptr; i++) {
            fast = fast->next;
        }
        
        while (fast->next != nullptr) {
            fast = fast->next;
            slow = slow->next;
        }
        
        slow->next = slow->next->next;
        
        return dummy->next;
    }
};
```

### 删除链表元素

```c++

class Solution {
public:
ListNode* removeElements(ListNode* head, int val) 
{
        ListNode * cur=new ListNode(0); 
        cur->next=head;
        ListNode* fast=head;
        ListNode* slow=cur;
        while(fast!=nullptr)
        {
            if(fast->val==val)
            {
                slow->next=fast->next;
                fast=fast->next;
            }
            else
            {
                fast=fast->next;
                slow=slow->next;
            }
        }
        return cur->next;
}
};
```



## 4.链表双指针

### 4.1 双指针检测环形链表

**一个快指针一个慢指针，快指针走两步，慢指针走一步。当它们能相等时就是环形链表**

```c++

class Solution {
public:
    bool hasCycle(ListNode *head) 
    {
        if(head==nullptr||head->next==nullptr)
        {
            return false;
        }
        ListNode* fast=head->next;
        ListNode* slow=head;
        while(fast!=slow)
        {
            if(fast==nullptr||fast->next==nullptr)
            {
                return false;
            }
            fast=fast->next->next;
            slow=slow->next;
        }
        return true;
    }
};
```

### 4.2 相交节点

**我的思路是两个遍历节点分别从两个链表头节点开始遍历，一个节点遍历完当前链表就继续遍历另一链表，另一个节点遍历过程也一样。若它们相等则返回节点值，否则没相交节点返回null**

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) 
    {
        if(headA==nullptr||headB==nullptr)
        {
            return nullptr;
        }
        ListNode* a1=headA;
        ListNode* a2=headB;
        while(a1!=a2)
        {
            if(a1==NULL)
            {
                a1=headB;
            }
            else
            {
                a1=a1->next;
            }
            if(a2==NULL)
            {
                a2=headA;
            }
            else
            {
                a2=a2->next;
            }
        }
        return a1;
    }
};
```







# 二叉树

## 二叉树定义

```c++
二叉树定义和链表类似
  struct treenode
  {
      int val;
      treenode *left;
      treenode *right;
      treenode(int x):val(x),left(nullptr),right(nullptr){}
  }
```

## 二叉树遍历

### 1 前中后序遍历—递归

```c++
前中后序遍历的区别是 根节点在哪个位置
根节点在前面就是 根左右 前序遍历
根节点在中间就是 左根右 中序遍历
```

```c++
//前序遍历
//travel 递归算法，导入的参数应该为根节点和存储值的vector
void travel(treenode *root,vector<int> num)
{
    if(root==nullptr)return;(遇到空节点返回)
    
    num.push_back(root->val);
    travel(root->left, num);     //push放前面
    travel(root->right, num);
    
}

vector<int> travel(treenode *root)//递归遍历
{
    vector<int>num;
    travel(root,num);
    return num;
}
```

```c++
//中序遍历
void travel(treenode *root,vector<int> num)
{
    if(root==nullptr)return;(遇到空节点返回)
    
   
    travel(root->left, num);   
    num.push_back(root->val);//push放中间
    travel(root->right, num);
    
}

vector<int> travel(treenode *root)//递归遍历
{
    vector<int>num;
    travel(root,num);
    return num;
}
```



```c++
//后序遍历
void travel(treenode *root,vector<int> num)
{
    if(root==nullptr)return;(遇到空节点返回)
    
   
    travel(root->left, num);   
    travel(root->right, num);
    num.push_back(root->val);//push放后面
    
}

vector<int> travel(treenode *root)//递归遍历
{
    vector<int>num;
    travel(root,num);
    return num;
}
```



### 2 层序遍历

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) 
    {
        queue<TreeNode*>que;//用队列来存一层的节点
        if(root!=nullptr)que.push(root);
        vector<vector<int>>result;
        while(!que.empty())
        {
            int size=que.size();
            vector<int>vec;//保存一层的节点值

            for(int i=0;i<size;i++)
            {
                TreeNode*node=que.front();//一个个节点来遍历，保存该节点，队列弹出该节点
                que.pop();
                vec.push_back(node->val);
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            result.push_back(vec);//在二维结果存入一层的值

        }
        return result;
    }
};
```



## 最大深度 （高度）

```c++
class Solution {
public:
    int maxDepth(TreeNode* root) 
    {   
        if(root==nullptr) return 0;
        int leftheight=maxDepth(root->left);
        int rightheight=maxDepth(root->right);
        int height =1+max(leftheight,rightheight);
        return height;

    }
};
```

## 判断对称

递归来做

```c++

class Solution {
public:
    bool compare(TreeNode* left,TreeNode*right)
    {
        // 首先排除空节点的情况
        if (left == NULL && right != NULL) return false;
        else if (left != NULL && right == NULL) return false;
        else if (left == NULL && right == NULL) return true;
        else if(left->val!=right->val) return false;
        {
            bool outside = compare(left->left, right->right);   // 左子树：左、 右子树：右
            bool inside = compare(left->right, right->left);    // 左子树：右、 右子树：左
            bool isduicheng=(outside&&inside);
            return isduicheng;
        }
    }
    bool isSymmetric(TreeNode* root) 
    {
        if(root==nullptr) return true;
        return  compare(root->left,root->right);

    }
};
```



## 验证二叉搜索树

**有效** 二叉搜索树定义如下：

- 节点的左子树只包含 **小于** 当前节点的数。

- 节点的右子树只包含 **大于** 当前节点的数。

- 所有左子树和右子树自身必须也是二叉搜索树。

  

**根据二叉搜索树的特性，用中序遍历。遍历出来左中右正好是递增的数组**

```c++
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        traversal(root);
        for(int i=0;i<path.size()-1;i++){
            if(path[i]>=path[i+1]) return false;
        }
        return true;
    }

    void traversal(TreeNode* root){
        if(root==nullptr) return;
        traversal(root->left);
        path.push_back(root->val);
        traversal(root->right);
    }
private:
    vector<int> path;
};
```



# 学习建议

C++这个实际工作中这点技术难以找到开发工作.学完这个之后再去学一下C++多线程(系统和C++11都要会理解).这个很重要.然后是socket(能够写出来C/S程序).这个2点学完了.基础才算打下去了.然后再去学一门框架.比如说QT开发.再看看源码.然后伪装一份简历.就可以去面试呢.

c++ 多线程 Linux系统编程

我也是个c++菜鸟。书籍也就是《c++ primer》、《effective c++》入了门再看、《stl源码剖析》先不用看那么多，不要太陷入c++的语法细节，这样会浪费你大把时间。入了门后看你以后想做什么，就学习一些相关的知识。比如Linux方向，那就买一本《lunix环境高级编程》，看这本之前先看一下《unix/Linux编程实战教程》总之不要太陷入c++的语法细节，如果你有工作了，可以业余买一些书籍学习学习。本身我是菜鸟，给你推荐不了太多的书籍，我还有达到那一步。





